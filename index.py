import os
import requests
import threading
import time
import schedule
import json
import asyncio
import logging
from datetime import datetime, timedelta
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes, CallbackQueryHandler
from apscheduler.schedulers.background import BackgroundScheduler

# Configura√ß√£o de logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler('bot_weather.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Configura√ß√µes principais
LATITUDE = -5.880287730015802
LONGITUDE = -35.24775350308109
CIDADE_NOME = "Natal, RN"
UPDATE_INTERVAL = 30  # minutos para verificar previs√£o
ALERT_THRESHOLD = 70  # % de chance de chuva para alertas

# Cache de dados
weather_cache = {
    'data': None,
    'timestamp': None,
    'cache_duration': 15  # minutos
}

# Estado dos alertas
alert_state = {
    'last_rain_alert': None,
    'last_wind_alert': None,
    'last_temp_alert': None,
    'morning_sent': False,
    'evening_sent': False,
    'users_subscribed': set(),
    'drone_locations': {}  # Novamente adicionado para compatibilidade
}

# Configura√ß√µes do Drone
DRONE_CONFIG = {
    'modelo': 'DJI Mini 2',
    'peso': 249,  # gramas
    'max_altitude': 120,  # metros
    'max_wind_resistance': 38,  # km/h
    'min_temp_operation': 0,  # ¬∞C
    'max_temp_operation': 40,  # ¬∞C
    'max_distance': 10000,  # metros
    'bateria_duracao': 31  # minutos
}

# Limites de seguran√ßa para voo
FLIGHT_LIMITS = {
    'max_wind': 35,  # km/h (recomendado abaixo do limite m√°ximo do drone)
    'min_visibility': 3,  # km
    'max_rain_chance': 30,  # %
    'min_temp': 0,  # ¬∞C
    'max_temp': 40,  # ¬∞C
}

def obter_previsao_tempo(latitude, longitude):
    """
    Obt√©m a previs√£o do tempo com cache para evitar muitas requisi√ß√µes
    """
    try:
        # Verifica se h√° dados em cache v√°lidos
        if (weather_cache['data'] and weather_cache['timestamp'] and 
            datetime.now() - weather_cache['timestamp'] < timedelta(minutes=weather_cache['cache_duration'])):
            logger.info("Usando dados do cache")
            return weather_cache['data']
        
        api_key = os.getenv("WEATHERAPI_KEY")
        if not api_key:
            logger.error("Chave da API do WeatherAPI n√£o configurada")
            return None
        
        url = f"http://api.weatherapi.com/v1/forecast.json?key={api_key}&q={latitude},{longitude}&days=7&aqi=yes&alerts=yes"
        
        logger.info(f"Fazendo requisi√ß√£o para API do tempo: {url}")
        response = requests.get(url, timeout=10)
        
        if response.status_code != 200:
            logger.error(f"Erro na API: {response.status_code} - {response.text}")
            return None
        
        data = response.json()
        
        # Atualiza o cache
        weather_cache['data'] = data
        weather_cache['timestamp'] = datetime.now()
        
        logger.info("Dados de previs√£o atualizados com sucesso")
        return data
        
    except requests.exceptions.RequestException as e:
        logger.error(f"Erro de conex√£o com a API: {e}")
        return None
    except Exception as e:
        logger.error(f"Erro inesperado ao obter previs√£o: {e}")
        return None

def formatar_condicao_tempo(condicao_en):
    """
    Traduz condi√ß√µes do tempo para portugu√™s
    """
    traducoes = {
        'Clear': 'C√©u limpo',
        'Sunny': 'Ensolarado',
        'Partly cloudy': 'Parcialmente nublado',
        'Cloudy': 'Nublado',
        'Overcast': 'Encoberto',
        'Mist': 'N√©voa',
        'Patchy rain possible': 'Possibilidade de chuva isolada',
        'Patchy snow possible': 'Possibilidade de neve isolada',
        'Patchy sleet possible': 'Possibilidade de chuva com granizo',
        'Patchy freezing drizzle possible': 'Possibilidade de garoa congelante',
        'Thundery outbreaks possible': 'Possibilidade de trovoadas',
        'Blowing snow': 'Neve ventosa',
        'Blizzard': 'Nevasca',
        'Fog': 'N√©voa densa',
        'Freezing fog': 'N√©voa congelante',
        'Patchy light drizzle': 'Garoa leve isolada',
        'Light drizzle': 'Garoa leve',
        'Freezing drizzle': 'Garoa congelante',
        'Heavy freezing drizzle': 'Garoa congelante forte',
        'Patchy light rain': 'Chuva leve isolada',
        'Light rain': 'Chuva leve',
        'Moderate rain at times': 'Chuva moderada ocasional',
        'Moderate rain': 'Chuva moderada',
        'Heavy rain at times': 'Chuva forte ocasional',
        'Heavy rain': 'Chuva forte',
        'Light freezing rain': 'Chuva congelante leve',
        'Moderate or heavy freezing rain': 'Chuva congelante moderada/forte',
        'Light sleet': 'Chuva com granizo leve',
        'Moderate or heavy sleet': 'Chuva com granizo moderada/forte',
        'Patchy light snow': 'Neve leve isolada',
        'Light snow': 'Neve leve',
        'Patchy moderate snow': 'Neve moderada isolada',
        'Moderate snow': 'Neve moderada',
        'Patchy heavy snow': 'Neve forte isolada',
        'Heavy snow': 'Neve forte',
        'Ice pellets': 'Granizo',
        'Light rain shower': 'Pancada de chuva leve',
        'Moderate or heavy rain shower': 'Pancada de chuva moderada/forte',
        'Torrential rain shower': 'Pancada de chuva torrencial',
        'Light sleet showers': 'Pancadas de chuva com granizo leves',
        'Moderate or heavy sleet showers': 'Pancadas de chuva com granizo moderadas/fortes',
        'Light snow showers': 'Pancadas de neve leves',
        'Moderate or heavy snow showers': 'Pancadas de neve moderadas/fortes',
        'Patchy light rain with thunder': 'Chuva leve com trovoadas isoladas',
        'Moderate or heavy rain with thunder': 'Chuva moderada/forte com trovoadas',
        'Patchy light snow with thunder': 'Neve leve com trovoadas isoladas',
        'Moderate or heavy snow with thunder': 'Neve moderada/forte com trovoadas'
    }
    return traducoes.get(condicao_en, condicao_en)

def obter_emoji_tempo(condicao):
    """
    Retorna emoji apropriado para a condi√ß√£o do tempo
    """
    emojis = {
        'Clear': '‚òÄÔ∏è', 'Sunny': '‚òÄÔ∏è',
        'Partly cloudy': '‚õÖ', 'Cloudy': '‚òÅÔ∏è', 'Overcast': '‚òÅÔ∏è',
        'Mist': 'üå´Ô∏è', 'Fog': 'üå´Ô∏è',
        'Light rain': 'üå¶Ô∏è', 'Moderate rain': 'üåßÔ∏è', 'Heavy rain': '‚õàÔ∏è',
        'Thundery outbreaks possible': '‚õàÔ∏è',
        'Light snow': 'üå®Ô∏è', 'Heavy snow': '‚ùÑÔ∏è'
    }
    
    for key, emoji in emojis.items():
        if key.lower() in condicao.lower():
            return emoji
    return 'üå§Ô∏è'

def criar_menu_voltar():
    """
    Cria o bot√£o para voltar ao menu principal
    """
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Menu", callback_data='voltar_menu')]
    ])

async def enviar_resposta(update_obj, mensagem, reply_markup=None):
    """
    Fun√ß√£o auxiliar para enviar resposta seja de comando ou callback
    """
    try:
        if hasattr(update_obj, 'callback_query') and update_obj.callback_query:
            # √â um callback de bot√£o
            await update_obj.callback_query.message.edit_text(
                text=mensagem,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
        else:
            # √â um comando direto
            await update_obj.message.reply_text(
                text=mensagem,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
    except Exception as e:
        logger.error(f"Erro ao enviar resposta: {e}")
        try:
            # Tenta enviar uma nova mensagem como fallback
            if hasattr(update_obj, 'callback_query') and update_obj.callback_query:
                await update_obj.callback_query.message.reply_text(
                    text=mensagem,
                    reply_markup=reply_markup,
                    parse_mode='Markdown'
                )
            else:
                await update_obj.message.reply_text(
                    text=mensagem,
                    reply_markup=reply_markup,
                    parse_mode='Markdown'
                )
        except Exception as e2:
            logger.error(f"Erro no fallback: {e2}")

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Comando inicial do bot com menu interativo
    """
    user_id = update.effective_user.id
    alert_state['users_subscribed'].add(user_id)
    
    keyboard = [
        # Clima e Previs√µes
        [InlineKeyboardButton("üå°Ô∏è Clima Atual", callback_data='clima_atual')],
        [InlineKeyboardButton("üåßÔ∏è Chance de Chuva", callback_data='chance_chuva')],
        [InlineKeyboardButton("üìÖ Pr√≥ximos Dias", callback_data='proximos_dias')],
        
        # Lona e Prote√ß√£o
        [InlineKeyboardButton("üè† Status da Lona", callback_data='status_lona')],
        [InlineKeyboardButton("üìä Relat√≥rio Completo", callback_data='relatorio_completo')],
        
        # Drone
        [InlineKeyboardButton("üöÅ Status para Voo", callback_data='status_drone')],
        [InlineKeyboardButton("üìç Gerenciar Locais", callback_data='locais_drone')],
        
        # Configura√ß√µes
        [InlineKeyboardButton("üîî Alertas", callback_data='config_alertas')],
        [InlineKeyboardButton("‚ùì Ajuda", callback_data='ajuda')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    mensagem_boas_vindas = f"""
ü§ñ **Bot de Previs√£o do Tempo - {CIDADE_NOME}**

Ol√°, {update.effective_user.first_name}! üëã

Eu sou seu assistente pessoal de previs√£o do tempo e monitoramento. Posso te ajudar com:

**üå°Ô∏è PREVIS√ÉO DO TEMPO:**
‚Ä¢ Temperatura e condi√ß√µes atuais
‚Ä¢ Chance de chuva nas pr√≥ximas horas
‚Ä¢ Previs√£o para a semana
‚Ä¢ Alertas meteorol√≥gicos

**üè† PROTE√á√ÉO:**
‚Ä¢ Status da lona da amora
‚Ä¢ Recomenda√ß√µes de prote√ß√£o
‚Ä¢ Alertas autom√°ticos
‚Ä¢ Monitoramento 24h

**üöÅ DRONE DJI Mini 2:**
‚Ä¢ Condi√ß√µes para voo
‚Ä¢ An√°lise de seguran√ßa
‚Ä¢ Monitoramento de locais
‚Ä¢ Limites operacionais

**üìä RELAT√ìRIOS:**
‚Ä¢ An√°lises detalhadas
‚Ä¢ Dados t√©cnicos
‚Ä¢ Hist√≥rico e tend√™ncias
‚Ä¢ Alertas customizados

**‚öôÔ∏è COMANDOS R√ÅPIDOS:**
‚Ä¢ /clima - Condi√ß√µes atuais
‚Ä¢ /chuva - Previs√£o de chuva
‚Ä¢ /diasdechuva - Previs√£o semanal
‚Ä¢ /baixarlona - Status da lona
‚Ä¢ /drone - Status para voo
‚Ä¢ /addlocal - Adicionar local
‚Ä¢ /relatorio - Relat√≥rio completo
‚Ä¢ /alertas - Configurar alertas
‚Ä¢ /help - Ajuda detalhada

üìç Local atual: {CIDADE_NOME}
üîÑ Atualiza√ß√£o: a cada {UPDATE_INTERVAL} minutos
üîî Alertas: {ALERT_THRESHOLD}% chance de chuva

Selecione uma op√ß√£o abaixo ou use os comandos! üëá
"""
    
    await update.message.reply_text(
        mensagem_boas_vindas,
        reply_markup=reply_markup,
        parse_mode='Markdown'
    )
    logger.info(f"Usu√°rio {user_id} iniciou o bot")

async def voltar_menu_principal(update_obj, context):
    """
    Retorna ao menu principal
    """
    keyboard = [
        [InlineKeyboardButton("üå°Ô∏è Clima Atual", callback_data='clima_atual')],
        [InlineKeyboardButton("üåßÔ∏è Chance de Chuva", callback_data='chance_chuva')],
        [InlineKeyboardButton("üìÖ Pr√≥ximos Dias", callback_data='proximos_dias')],
        [InlineKeyboardButton("üè† Status da Lona", callback_data='status_lona')],
        [InlineKeyboardButton("üìä Relat√≥rio Completo", callback_data='relatorio_completo')],
        [InlineKeyboardButton("üöÅ Status para Voo", callback_data='status_drone')],
        [InlineKeyboardButton("üìç Gerenciar Locais", callback_data='locais_drone')],
        [InlineKeyboardButton("üîî Alertas", callback_data='config_alertas')],
        [InlineKeyboardButton("‚ùì Ajuda", callback_data='ajuda')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    mensagem = """
ü§ñ **MENU PRINCIPAL**

Selecione uma op√ß√£o:

üå°Ô∏è Clima Atual
üåßÔ∏è Chance de Chuva
üìÖ Pr√≥ximos Dias
üè† Status da Lona
üìä Relat√≥rio Completo
üöÅ Status para Voo
üìç Gerenciar Locais
üîî Alertas
‚ùì Ajuda
"""
    await enviar_resposta(update_obj, mensagem, reply_markup)

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Manipula os bot√µes interativos do menu
    """
    query = update.callback_query
    await query.answer()
    
    handlers = {
        'clima_atual': clima_atual_detalhado,
        'chance_chuva': previsao_chuva_detalhada,
        'proximos_dias': previsao_proximos_dias,
        'status_lona': status_lona_detalhado,
        'relatorio_completo': relatorio_meteorologico_completo,
        'status_drone': status_voo_drone,
        'locais_drone': gerenciar_locais_drone,
        'config_alertas': configurar_alertas,
        'ajuda': ajuda_detalhada,
        'voltar_menu': voltar_menu_principal,
        'alert_rain_on': ativar_alertas_chuva,
        'alert_rain_off': desativar_alertas_chuva,
        'alert_status': status_alertas
    }
    
    try:
        if query.data.startswith('check_drone_'):
            local = query.data.replace('check_drone_', '')
            if local in alert_state['drone_locations']:
                coords = alert_state['drone_locations'][local]
                resultado = await verificar_condicoes_voo(coords['latitude'], coords['longitude'], local)
                if resultado:
                    await status_voo_drone(update, context, resultado)
                else:
                    await query.message.reply_text("‚ùå Erro ao verificar condi√ß√µes para este local")
            return

        if query.data in handlers:
            await handlers[query.data](update, context)
        else:
            logger.warning(f"Callback n√£o tratado: {query.data}")
            await query.message.reply_text("‚ùå Op√ß√£o inv√°lida ou n√£o implementada")
            
    except Exception as e:
        logger.error(f"Erro no button_handler: {e}")
        await query.message.reply_text("‚ùå Ocorreu um erro ao processar sua solicita√ß√£o")

# Adicione estas novas fun√ß√µes para gerenciar locais do drone
async def gerenciar_locais_drone(update_obj, context):
    """
    Menu para gerenciar locais salvos para o drone
    """
    keyboard = []
    
    # Lista locais salvos
    if alert_state['drone_locations']:
        mensagem = "üìç **LOCAIS SALVOS PARA DRONE**\n\n"
        for nome, coords in alert_state['drone_locations'].items():
            mensagem += f"‚Ä¢ {nome}: {coords['latitude']}, {coords['longitude']}\n"
            keyboard.append([InlineKeyboardButton(
                f"üöÅ Verificar {nome}", 
                callback_data=f"check_drone_{nome}"
            )])
    else:
        mensagem = "üìç **GERENCIAR LOCAIS DO DRONE**\n\n"
        mensagem += "Nenhum local salvo ainda.\n\n"
    
    mensagem += "\n**Para adicionar um novo local:**\n"
    mensagem += "Use o comando /addlocal nome latitude longitude\n"
    mensagem += "Exemplo: `/addlocal Parque -5.8802 -35.2477`"
    
    # Adiciona bot√£o de voltar
    keyboard.append([InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Menu", callback_data='voltar_menu')])
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await enviar_resposta(update_obj, mensagem, reply_markup)

async def ativar_alertas_chuva(update_obj, context):
    """
    Ativa alertas de chuva para o usu√°rio
    """
    user_id = update_obj.effective_user.id
    alert_state['users_subscribed'].add(user_id)
    
    mensagem = """
‚úÖ **ALERTAS ATIVADOS**

Voc√™ receber√° notifica√ß√µes para:
‚Ä¢ üåßÔ∏è Chuva forte (>70% de chance)
‚Ä¢ üå°Ô∏è Temperaturas extremas
‚Ä¢ üí® Ventos fortes
‚Ä¢ ‚è∞ Relat√≥rios di√°rios (7h e 19h)

Os alertas s√£o verificados a cada 30 minutos.
"""
    await enviar_resposta(update_obj, mensagem, criar_menu_voltar())

async def desativar_alertas_chuva(update_obj, context):
    """
    Desativa alertas de chuva para o usu√°rio
    """
    user_id = update_obj.effective_user.id
    alert_state['users_subscribed'].discard(user_id)
    
    mensagem = """
üîï **ALERTAS DESATIVADOS**

Voc√™ n√£o receber√° mais notifica√ß√µes autom√°ticas.
Use /alertas para reativar quando quiser.
"""
    await enviar_resposta(update_obj, mensagem, criar_menu_voltar())

async def status_alertas(update_obj, context):
    """
    Mostra o status atual dos alertas
    """
    user_id = update_obj.effective_user.id
    status_ativo = user_id in alert_state['users_subscribed']
    
    mensagem = f"""
üìã **STATUS DOS ALERTAS**

Status atual: {"üîî ATIVO" if status_ativo else "üîï DESATIVADO"}

**Configura√ß√µes:**
‚Ä¢ Intervalo: {UPDATE_INTERVAL} minutos
‚Ä¢ Limite chuva: {ALERT_THRESHOLD}%
‚Ä¢ Relat√≥rios: 7h e 19h

{("‚úÖ Voc√™ est√° recebendo alertas" if status_ativo else "‚ùå Alertas desativados")}
"""
    await enviar_resposta(update_obj, mensagem, criar_menu_voltar())

async def clima_atual_detalhado(update_obj, context):
    """
    Mostra informa√ß√µes detalhadas do clima atual
    """
    previsao = obter_previsao_tempo(LATITUDE, LONGITUDE)
    if not previsao:
        await enviar_resposta(update_obj, "‚ùå N√£o foi poss√≠vel obter dados meteorol√≥gicos no momento.", criar_menu_voltar())
        return
    
    current = previsao["current"]
    location = previsao["location"]
    
    temperatura = current["temp_c"]
    sensacao = current["feelslike_c"]
    condicao = formatar_condicao_tempo(current["condition"]["text"])
    emoji = obter_emoji_tempo(current["condition"]["text"])
    umidade = current["humidity"]
    vento_kph = current["wind_kph"]
    vento_dir = current["wind_dir"]
    pressao = current["pressure_mb"]
    visibilidade = current["vis_km"]
    uv_index = current["uv"]
    
    # Classifica√ß√£o do UV
    if uv_index <= 2:
        uv_status = "Baixo üü¢"
    elif uv_index <= 5:
        uv_status = "Moderado üü°"
    elif uv_index <= 7:
        uv_status = "Alto üü†"
    elif uv_index <= 10:
        uv_status = "Muito Alto üî¥"
    else:
        uv_status = "Extremo üü£"
    
    mensagem = f"""
{emoji} **CLIMA ATUAL - {location['name']}**

üå°Ô∏è **Temperatura:** {temperatura}¬∞C
üå°Ô∏è **Sensa√ß√£o t√©rmica:** {sensacao}¬∞C
üå§Ô∏è **Condi√ß√£o:** {condicao}

üíß **Umidade:** {umidade}%
üí® **Vento:** {vento_kph} km/h {vento_dir}
üìä **Press√£o:** {pressao} mb
üëÅÔ∏è **Visibilidade:** {visibilidade} km
‚òÄÔ∏è **√çndice UV:** {uv_index} ({uv_status})

üìç **Localiza√ß√£o:** {location['name']}, {location['region']}
üïê **√öltima atualiza√ß√£o:** {current['last_updated']}

**Recomenda√ß√µes:**
"""
    
    # Adiciona recomenda√ß√µes baseadas nas condi√ß√µes
    if temperatura > 30:
        mensagem += "‚Ä¢ üå°Ô∏è Dia quente! Beba bastante √°gua e evite exposi√ß√£o prolongada ao sol\n"
    elif temperatura < 18:
        mensagem += "‚Ä¢ üß• Temperatura baixa! Use roupas quentes\n"
    
    if umidade > 80:
        mensagem += "‚Ä¢ üíß Umidade alta! Pode haver desconforto\n"
    elif umidade < 30:
        mensagem += "‚Ä¢ üèúÔ∏è Ar seco! Mantenha-se hidratado\n"
    
    if vento_kph > 30:
        mensagem += "‚Ä¢ üí® Vento forte! Cuidado com objetos soltos\n"
    
    if uv_index > 7:
        mensagem += "‚Ä¢ ‚òÄÔ∏è √çndice UV alto! Use protetor solar\n"
    
    await enviar_resposta(update_obj, mensagem, criar_menu_voltar())

async def previsao_chuva_detalhada(update_obj, context):
    """
    Previs√£o detalhada de chuva para as pr√≥ximas horas
    """
    previsao = obter_previsao_tempo(LATITUDE, LONGITUDE)
    if not previsao:
        await enviar_resposta(update_obj, "‚ùå N√£o foi poss√≠vel obter previs√£o de chuva.", criar_menu_voltar())
        return
    
    hoje = previsao["forecast"]["forecastday"][0]
    horas = hoje["hour"]
    
    agora = datetime.now().hour
    mensagem = f"üåßÔ∏è **PREVIS√ÉO DE CHUVA - PR√ìXIMAS 12 HORAS**\n\n"
    
    max_chance = 0
    
    for i in range(12):
        hora_index = (agora + i) % 24
        if hora_index < len(horas):
            hora_data = horas[hora_index]
            time_str = hora_data["time"].split(" ")[1]
            chance = hora_data.get("chance_of_rain", 0)
            precipitacao = hora_data.get("precip_mm", 0)
            
            if chance > max_chance:
                max_chance = chance
            
            # Emoji baseado na chance de chuva
            if chance >= 80:
                emoji = "‚õàÔ∏è"
            elif chance >= 60:
                emoji = "üåßÔ∏è"
            elif chance >= 30:
                emoji = "üå¶Ô∏è"
            else:
                emoji = "‚òÅÔ∏è"
            
            mensagem += f"{emoji} **{time_str}** - {chance}% "
            if precipitacao > 0:
                mensagem += f"({precipitacao}mm)"
            mensagem += "\n"
    
    # Resumo e recomenda√ß√µes
    mensagem += f"\nüìä **RESUMO:**\n"
    mensagem += f"‚Ä¢ Maior chance de chuva: {max_chance}%\n"
    
    if max_chance >= 70:
        mensagem += "‚Ä¢ ‚ö†Ô∏è **ALERTA:** Alta probabilidade de chuva!\n"
        mensagem += "‚Ä¢ üè† **RECOMENDA√á√ÉO:** Baixe a lona da amora\n"
        mensagem += "‚Ä¢ ‚òÇÔ∏è Leve guarda-chuva se sair de casa\n"
    elif max_chance >= 40:
        mensagem += "‚Ä¢ üå¶Ô∏è Possibilidade moderada de chuva\n"
        mensagem += "‚Ä¢ ‚òÇÔ∏è Considere levar guarda-chuva\n"
    else:
        mensagem += "‚Ä¢ ‚òÄÔ∏è Baixa chance de chuva\n"
        mensagem += "‚Ä¢ üè† Lona da amora pode ficar no lugar\n"
    
    await enviar_resposta(update_obj, mensagem, criar_menu_voltar())

async def previsao_proximos_dias(update_obj, context):
    """
    Previs√£o para os pr√≥ximos 7 dias
    """
    previsao = obter_previsao_tempo(LATITUDE, LONGITUDE)
    if not previsao:
        await enviar_resposta(update_obj, "‚ùå N√£o foi poss√≠vel obter previs√£o dos pr√≥ximos dias.", criar_menu_voltar())
        return
    
    dias = previsao["forecast"]["forecastday"]
    mensagem = "üìÖ **PREVIS√ÉO PARA OS PR√ìXIMOS 7 DIAS**\n\n"
    
    dias_da_semana = {
        'monday': 'Segunda-feira',
        'tuesday': 'Ter√ßa-feira', 
        'wednesday': 'Quarta-feira',
        'thursday': 'Quinta-feira',
        'friday': 'Sexta-feira',
        'saturday': 'S√°bado',
        'sunday': 'Domingo'
    }
    
    for i, dia in enumerate(dias):
        data_obj = datetime.strptime(dia["date"], "%Y-%m-%d")
        if i == 0:
            data_nome = "Hoje"
        elif i == 1:
            data_nome = "Amanh√£"
        else:
            nome_dia_en = data_obj.strftime("%A").lower()
            data_nome = dias_da_semana.get(nome_dia_en, data_obj.strftime("%A"))
        
        data_formatada = data_obj.strftime("%d/%m")
        day_data = dia["day"]
        
        temp_max = day_data["maxtemp_c"]
        temp_min = day_data["mintemp_c"]
        condicao = formatar_condicao_tempo(day_data["condition"]["text"])
        emoji = obter_emoji_tempo(day_data["condition"]["text"])
        chance_chuva = day_data.get("daily_chance_of_rain", 0)
        precipitacao = day_data.get("totalprecip_mm", 0)
        
        mensagem += f"{emoji} **{data_nome} ({data_formatada})**\n"
        mensagem += f"üå°Ô∏è {temp_min}¬∞C - {temp_max}¬∞C\n"
        mensagem += f"üå§Ô∏è {condicao}\n"
        mensagem += f"üåßÔ∏è Chuva: {chance_chuva}%"
        
        if precipitacao > 0:
            mensagem += f" ({precipitacao}mm)"
        
        if chance_chuva > 70:
            mensagem += " ‚ö†Ô∏è"
        
        mensagem += "\n\n"
    
    # Adiciona resumo da semana
    dias_chuva = sum(1 for dia in dias if dia["day"].get("daily_chance_of_rain", 0) > 50)
    mensagem += f"üìä **RESUMO DA SEMANA:**\n"
    mensagem += f"‚Ä¢ Dias com chance de chuva (>50%): {dias_chuva}\n"
    
    if dias_chuva >= 4:
        mensagem += "‚Ä¢ üåßÔ∏è Semana chuvosa prevista\n"
    elif dias_chuva >= 2:
        mensagem += "‚Ä¢ üå¶Ô∏è Alguns dias de chuva\n"
    else:
        mensagem += "‚Ä¢ ‚òÄÔ∏è Semana predominantemente seca\n"
    
    await enviar_resposta(update_obj, mensagem, criar_menu_voltar())

async def status_lona_detalhado(update_obj, context):
    """
    Status detalhado sobre a necessidade de baixar a lona
    """
    previsao = obter_previsao_tempo(LATITUDE, LONGITUDE)
    if not previsao:
        await enviar_resposta(update_obj, "‚ùå N√£o foi poss√≠vel verificar status da lona.", criar_menu_voltar())
        return
    
    hoje = previsao["forecast"]["forecastday"][0]
    amanha = previsao["forecast"]["forecastday"][1] if len(previsao["forecast"]["forecastday"]) > 1 else None
    
    # Verifica chuva das 18h √†s 6h (per√≠odo noturno)
    horas_noite = []
    for hora in hoje["hour"]:
        time_str = hora["time"].split(" ")[1]
        hour_num = int(time_str.split(":")[0])
        if hour_num >= 18 or hour_num <= 6:
            horas_noite.append(hora)
    
    if amanha:
        for hora in amanha["hour"][:7]:  # primeiras 7 horas do dia seguinte (at√© 6h)
            horas_noite.append(hora)
    
    max_chance_noite = max(int(hora.get("chance_of_rain", 0)) for hora in horas_noite) if horas_noite else 0
    precipitacao_total = sum(hora.get("precip_mm", 0) for hora in horas_noite)
    
    mensagem = "üè† **STATUS DA LONA DA AMORA**\n\n"
    
    if max_chance_noite > 70:
        status = "üî¥ **BAIXAR A LONA**"
        recomendacao = "‚ö†Ô∏è **A√á√ÉO NECESS√ÅRIA:** Baixe a lona da amora hoje √† tarde!"
        emoji_principal = "üõ°Ô∏è"
    elif max_chance_noite > 40:
        status = "üü° **ATEN√á√ÉO**"
        recomendacao = "‚ö†Ô∏è **CONSIDERE:** Monitorar a previs√£o e estar preparado para baixar a lona"
        emoji_principal = "‚ö†Ô∏è"
    else:
        status = "üü¢ **LONA PODE FICAR**"
        recomendacao = "‚úÖ **TRANQUILO:** N√£o h√° previs√£o de chuva forte para hoje √† noite"
        emoji_principal = "‚òÄÔ∏è"
    
    mensagem += f"{emoji_principal} **STATUS:** {status}\n\n"
    mensagem += f"üìä **AN√ÅLISE NOTURNA (18h-6h):**\n"
    mensagem += f"‚Ä¢ Maior chance de chuva: {max_chance_noite}%\n"
    mensagem += f"‚Ä¢ Precipita√ß√£o prevista: {precipitacao_total:.1f}mm\n\n"
    
    mensagem += f"üí° **RECOMENDA√á√ÉO:**\n{recomendacao}\n\n"
    
    # Detalhes por per√≠odo
    mensagem += "üïê **DETALHES POR PER√çODO:**\n"
    
    # Tarde (15h-18h)
    tarde_chances = [hora.get("chance_of_rain", 0) for hora in hoje["hour"][15:18]]
    tarde_max = max(tarde_chances) if tarde_chances else 0
    mensagem += f"‚Ä¢ üåÖ Tarde (15h-18h): {tarde_max}%\n"
    
    # Noite (18h-23h)
    noite_chances = [hora.get("chance_of_rain", 0) for hora in hoje["hour"][18:24]]
    noite_max = max(noite_chances) if noite_chances else 0
    mensagem += f"‚Ä¢ üåô Noite (18h-23h): {noite_max}%\n"
    
    # Madrugada (0h-6h)
    if amanha:
        madru_chances = [hora.get("chance_of_rain", 0) for hora in amanha["hour"][:6]]
        madru_max = max(madru_chances) if madru_chances else 0
        mensagem += f"‚Ä¢ üåå Madrugada (0h-6h): {madru_max}%\n"
    
    # Dicas adicionais
    mensagem += f"\nüí° **DICAS:**\n"
    if max_chance_noite > 70:
        mensagem += "‚Ä¢ Baixe a lona antes das 18h\n"
        mensagem += "‚Ä¢ Verifique se est√° bem fixada\n"
        mensagem += "‚Ä¢ Considere proteger outras plantas sens√≠veis\n"
    else:
        mensagem += "‚Ä¢ Continue monitorando a previs√£o\n"
        mensagem += "‚Ä¢ Mantenha a lona acess√≠vel caso necess√°rio\n"
    
    await enviar_resposta(update_obj, mensagem, criar_menu_voltar())

async def relatorio_meteorologico_completo(update_obj, context):
    """
    Relat√≥rio meteorol√≥gico completo e detalhado
    """
    previsao = obter_previsao_tempo(LATITUDE, LONGITUDE)
    if not previsao:
        await enviar_resposta(update_obj, "‚ùå N√£o foi poss√≠vel gerar relat√≥rio meteorol√≥gico.", criar_menu_voltar())
        return
    
    current = previsao["current"]
    hoje = previsao["forecast"]["forecastday"][0]
    
    # Cabe√ßalho
    mensagem = f"""
üìä **RELAT√ìRIO METEOROL√ìGICO COMPLETO**
üìÖ {datetime.now().strftime('%d/%m/%Y √†s %H:%M')}
üìç {CIDADE_NOME}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üå°Ô∏è **CONDI√á√ïES ATUAIS:**
‚Ä¢ Temperatura: {current['temp_c']}¬∞C (sensa√ß√£o: {current['feelslike_c']}¬∞C)
‚Ä¢ Condi√ß√£o: {formatar_condicao_tempo(current['condition']['text'])}
‚Ä¢ Umidade: {current['humidity']}%
‚Ä¢ Press√£o: {current['pressure_mb']} mb
‚Ä¢ Vento: {current['wind_kph']} km/h {current['wind_dir']}
‚Ä¢ Visibilidade: {current['vis_km']} km
‚Ä¢ √çndice UV: {current['uv']}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìà **EXTREMOS DE HOJE:**
‚Ä¢ M√°xima: {hoje['day']['maxtemp_c']}¬∞C
‚Ä¢ M√≠nima: {hoje['day']['mintemp_c']}¬∞C
‚Ä¢ Chance de chuva: {hoje['day'].get('daily_chance_of_rain', 0)}%
‚Ä¢ Precipita√ß√£o total: {hoje['day'].get('totalprecip_mm', 0)} mm
‚Ä¢ Vento m√°ximo: {hoje['day']['maxwind_kph']} km/h

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üåÖ **NASCER E P√îR DO SOL:**
‚Ä¢ Nascer: {hoje['astro']['sunrise']}
‚Ä¢ P√¥r do sol: {hoje['astro']['sunset']}
‚Ä¢ Nascer da lua: {hoje['astro']['moonrise']}
‚Ä¢ P√¥r da lua: {hoje['astro']['moonset']}
‚Ä¢ Fase da lua: {hoje['astro']['moon_phase']}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üåßÔ∏è **AN√ÅLISE DE CHUVA (PR√ìXIMAS 6H):**
"""
    
    # An√°lise detalhada das pr√≥ximas 6 horas
    agora = datetime.now().hour
    total_precip = 0
    max_chance = 0
    
    for i in range(6):
        hora_index = (agora + i) % 24
        if hora_index < len(hoje["hour"]):
            hora_data = hoje["hour"][hora_index]
            chance = hora_data.get("chance_of_rain", 0)
            precip = hora_data.get("precip_mm", 0)
            total_precip += precip
            if chance > max_chance:
                max_chance = chance
    
    mensagem += f"‚Ä¢ Maior chance: {max_chance}%\n"
    mensagem += f"‚Ä¢ Precipita√ß√£o total prevista: {total_precip:.1f}mm\n"
    
    if max_chance > 80:
        nivel_alerta = "üî¥ ALTO"
    elif max_chance > 50:
        nivel_alerta = "üü° M√âDIO"
    else:
        nivel_alerta = "üü¢ BAIXO"
    
    mensagem += f"‚Ä¢ N√≠vel de alerta: {nivel_alerta}\n"
    
    # Qualidade do ar se dispon√≠vel
    if 'air_quality' in current:
        aqi = current['air_quality']
        mensagem += f"\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        mensagem += f"üå¨Ô∏è **QUALIDADE DO AR:**\n"
        if 'pm2_5' in aqi:
            mensagem += f"‚Ä¢ PM2.5: {aqi['pm2_5']} Œºg/m¬≥\n"
        if 'pm10' in aqi:
            mensagem += f"‚Ä¢ PM10: {aqi['pm10']} Œºg/m¬≥\n"
    
    # Alertas meteorol√≥gicos se dispon√≠veis
    if 'alerts' in previsao and previsao['alerts']['alert']:
        mensagem += f"\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
        mensagem += f"‚ö†Ô∏è **ALERTAS METEOROL√ìGICOS:**\n"
        for alerta in previsao['alerts']['alert']:
            mensagem += f"‚Ä¢ {alerta['headline']}\n"
            mensagem += f"  Vig√™ncia: {alerta['effective']} at√© {alerta['expires']}\n"
    
    mensagem += f"\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
    mensagem += f"üè† **RECOMENDA√á√ÉO PARA A LONA:**\n"
    
    if max_chance > 70:
        mensagem += "üõ°Ô∏è **BAIXAR A LONA** - Alta chance de chuva!\n"
    elif max_chance > 40:
        mensagem += "‚ö†Ô∏è **FICAR ATENTO** - Possibilidade de chuva\n"
    else:
        mensagem += "‚úÖ **LONA PODE FICAR** - Baixo risco de chuva\n"
    
    mensagem += f"\nüì± Relat√≥rio gerado automaticamente √†s {datetime.now().strftime('%H:%M')}"
    
    await enviar_resposta(update_obj, mensagem, criar_menu_voltar())

async def configurar_alertas(update_obj, context):
    """
    Menu para configurar alertas autom√°ticos
    """
    logger.info("Abrindo menu de configura√ß√£o de alertas")
    
    keyboard = [
        [InlineKeyboardButton("üîî Ativar Alertas de Chuva", callback_data='alert_rain_on')],
        [InlineKeyboardButton("üîï Desativar Alertas de Chuva", callback_data='alert_rain_off')],
        [InlineKeyboardButton("üìã Status dos Alertas", callback_data='alert_status')],
        [InlineKeyboardButton("‚¨ÖÔ∏è Voltar ao Menu", callback_data='voltar_menu')]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    mensagem = """
üîî **CONFIGURA√á√ÉO DE ALERTAS**

**Alertas Dispon√≠veis:**

üåßÔ∏è **Alertas de Chuva**
‚Ä¢ Enviados quando chance > 70%
‚Ä¢ Verifica√ß√£o a cada 30 minutos
‚Ä¢ Inclui recomenda√ß√£o para lona

üå°Ô∏è **Alertas de Temperatura**
‚Ä¢ Temperaturas extremas
‚Ä¢ Ondas de calor ou frio

üí® **Alertas de Vento**
‚Ä¢ Ventos fortes (>50 km/h)
‚Ä¢ Rajadas perigosas

‚è∞ **Relat√≥rios Autom√°ticos**
‚Ä¢ Relat√≥rio matinal (7h)
‚Ä¢ Relat√≥rio noturno (19h)

Selecione uma op√ß√£o abaixo:
    """
    
    await enviar_resposta(update_obj, mensagem, reply_markup)

async def ajuda_detalhada(update_obj, context):
    """
    Ajuda detalhada com todos os comandos e funcionalidades
    """
    mensagem = f"""
‚ùì **AJUDA COMPLETA - BOT DE PREVIS√ÉO DO TEMPO**

ü§ñ **SOBRE O BOT:**
Este bot fornece informa√ß√µes meteorol√≥gicas detalhadas para {CIDADE_NOME}, incluindo previs√µes, alertas autom√°ticos e recomenda√ß√µes espec√≠ficas para cuidados com plantas.

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìã **COMANDOS DISPON√çVEIS:**

üå°Ô∏è **/clima** - Mostra clima atual detalhado
   ‚Ä¢ Temperatura e sensa√ß√£o t√©rmica
   ‚Ä¢ Condi√ß√µes atmosf√©ricas
   ‚Ä¢ Umidade, press√£o, vento
   ‚Ä¢ √çndice UV e recomenda√ß√µes

üåßÔ∏è **/chuva** - Previs√£o de chuva nas pr√≥ximas horas
   ‚Ä¢ Chance de chuva hora a hora
   ‚Ä¢ Quantidade de precipita√ß√£o
   ‚Ä¢ Recomenda√ß√µes de prote√ß√£o

üìÖ **/diasdechuva** - Pr√≥ximos dias com chuva
   ‚Ä¢ Previs√£o para 7 dias
   ‚Ä¢ An√°lise de padr√µes
   ‚Ä¢ Resumo semanal

üè† **/baixarlona** - Status da lona da amora
   ‚Ä¢ An√°lise per√≠odo noturno
   ‚Ä¢ Recomenda√ß√µes espec√≠ficas
   ‚Ä¢ Alertas de prote√ß√£o

üìä **/relatorio** - Relat√≥rio meteorol√≥gico completo
   ‚Ä¢ Dados t√©cnicos detalhados
   ‚Ä¢ An√°lises profissionais
   ‚Ä¢ Hist√≥rico e tend√™ncias

üîî **/alertas** - Configurar notifica√ß√µes autom√°ticas
   ‚Ä¢ Alertas de chuva forte
   ‚Ä¢ Notifica√ß√µes de temperatura
   ‚Ä¢ Relat√≥rios programados

‚ùì **/help** - Esta mensagem de ajuda

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üîî **ALERTAS AUTOM√ÅTICOS:**

O bot monitora constantemente as condi√ß√µes meteorol√≥gicas e envia alertas autom√°ticos para:

‚Ä¢ üåßÔ∏è Chuva forte (chance > 70%)
‚Ä¢ üå°Ô∏è Temperaturas extremas
‚Ä¢ üí® Ventos fortes (> 50 km/h)
‚Ä¢ üè† Necessidade de proteger plantas

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üè† **SISTEMA DA LONA:**

O bot possui um sistema inteligente para recomendar quando baixar a lona da amora baseado em:

‚Ä¢ An√°lise do per√≠odo noturno (18h-6h)
‚Ä¢ Intensidade da chuva prevista
‚Ä¢ Dire√ß√£o e for√ßa dos ventos
‚Ä¢ Hist√≥rico de precipita√ß√£o

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚öôÔ∏è **CONFIGURA√á√ïES:**

‚Ä¢ Localiza√ß√£o: {CIDADE_NOME}
‚Ä¢ Intervalo de verifica√ß√£o: 30 minutos
‚Ä¢ Limite para alertas: 70% chance de chuva
‚Ä¢ Idioma: Portugu√™s Brasileiro

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìû **SUPORTE:**

Em caso de problemas ou sugest√µes:
‚Ä¢ Use /start para reiniciar o bot
‚Ä¢ Comandos funcionam 24h por dia
‚Ä¢ Dados atualizados a cada 15 minutos

üåü **Desenvolvido especificamente para {CIDADE_NOME}**

üöÅ **COMANDOS PARA DRONE:**

‚Ä¢ /drone - Verifica condi√ß√µes para voo
   ‚Ä¢ Status atual detalhado
   ‚Ä¢ Recomenda√ß√µes de seguran√ßa
   ‚Ä¢ Limites do DJI Mini 2

‚Ä¢ /addlocal - Adiciona local para monitorar
   ‚Ä¢ Formato: /addlocal nome latitude longitude
   ‚Ä¢ Exemplo: /addlocal Parque -5.8802 -35.2477
"""
    
    await enviar_resposta(update_obj, mensagem, criar_menu_voltar())

async def verificar_condicoes():
    """
    Verifica condi√ß√µes meteorol√≥gicas atuais e envia alertas se necess√°rio
    """
    try:
        previsao = obter_previsao_tempo(LATITUDE, LONGITUDE)
        if not previsao:
            logger.error("N√£o foi poss√≠vel obter previs√£o para verifica√ß√£o autom√°tica")

        hoje = previsao["forecast"]["forecastday"][0]
        agora = datetime.now().hour
        proximas_horas = hoje["hour"][agora:agora + 3]  # Pr√≥ximas 3 horas

        # Verifica chance de chuva
        max_chance = max(int(hora.get("chance_of_rain", 0)) for hora in proximas_horas)
        if max_chance >= ALERT_THRESHOLD:
            # Envia alerta para todos usu√°rios inscritos
            mensagem = f"""‚ö†Ô∏è **ALERTA DE CHUVA**

Detectada alta probabilidade de chuva!

üåßÔ∏è Chance de chuva: {max_chance}%
‚è∞ Nas pr√≥ximas horas
üìç {CIDADE_NOME}

üè† **Recomenda√ß√£o:** Baixe a lona da amora!
"""
            for user_id in alert_state['users_subscribed']:
                try:
                    await bot.send_message(
                        chat_id=user_id,
                        text=mensagem,
                        parse_mode='Markdown'
                    )
                    logger.info(f"Alerta de chuva enviado para {user_id}")
                except Exception as e:
                    logger.error(f"Erro ao enviar alerta para {user_id}: {e}")

    except Exception as e:
        logger.error(f"Erro na verifica√ß√£o autom√°tica: {e}")

def executar_agenda():
    """
    Executa o agendador em loop
    """
    try:
        logger.info("Iniciando loop do agendador")
        while True:
            time.sleep(1)
    except (KeyboardInterrupt, SystemExit):
        logger.info("Loop do agendador interrompido")

def verificacao_automatica():
    """
    Fun√ß√£o para executar verifica√ß√£o em loop
    """
    logger.info("Iniciando verifica√ß√£o autom√°tica")
    
    try:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        async def verificacao_loop():
            while True:
                await verificar_condicoes()
                await asyncio.sleep(UPDATE_INTERVAL * 60)
        
        loop.run_until_complete(verificacao_loop())
    except Exception as e:
        logger.error(f"Erro no loop de verifica√ß√£o: {e}")
    finally:
        loop.close()

def configurar_agenda():
    """
    Configura as tarefas agendadas do bot
    """
    logger.info("Configurando agenda de tarefas")
    
    try:
        # Cria o agendador
        scheduler = BackgroundScheduler()
        
        # Agenda relat√≥rio matinal (7h)
        scheduler.add_job(
            enviar_relatorio_matinal,
            'cron',
            hour=7,
            minute=0,
            id='relatorio_matinal'
        )
        
        # Agenda relat√≥rio noturno (19h)
        scheduler.add_job(
            enviar_relatorio_noturno,
            'cron',
            hour=19,
            minute=0,
            id='relatorio_noturno'
        )
        
        # Inicia o agendador
        scheduler.start()
        logger.info("Agenda configurada com sucesso")
        
    except Exception as e:
        logger.error(f"Erro ao configurar agenda: {e}")
        print(f"‚ùå Erro ao configurar agenda: {e}")

async def enviar_relatorio_matinal():
    """
    Envia relat√≥rio meteorol√≥gico matinal
    """
    for user_id in alert_state['users_subscribed']:
        try:
            mensagem = "üåÖ **RELAT√ìRIO MATINAL**\n\n"
            # Adicione aqui a l√≥gica para gerar o relat√≥rio matinal
            await bot.send_message(chat_id=user_id, text=mensagem, parse_mode='Markdown')
            logger.info(f"Relat√≥rio matinal enviado para {user_id}")
        except Exception as e:
            logger.error(f"Erro ao enviar relat√≥rio matinal para {user_id}: {e}")

async def enviar_relatorio_noturno():
    """
    Envia relat√≥rio meteorol√≥gico noturno
    """
    for user_id in alert_state['users_subscribed']:
        try:
            mensagem = "üåô **RELAT√ìRIO NOTURNO**\n\n"
            # Adicione aqui a l√≥gica para gerar o relat√≥rio noturno
            await bot.send_message(chat_id=user_id, text=mensagem, parse_mode='Markdown')
            logger.info(f"Relat√≥rio noturno enviado para {user_id}")
        except Exception as e:
            logger.error(f"Erro ao enviar relat√≥rio noturno para {user_id}: {e}")

# Comandos simples para compatibilidade
async def clima(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /clima - vers√£o simples"""
    await clima_atual_detalhado(update, context)

async def chuva(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /chuva - vers√£o simples"""
    await previsao_chuva_detalhada(update, context)

async def diasdechuva(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /diasdechuva - vers√£o simples"""
    await previsao_proximos_dias(update, context)

async def baixarlona(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /baixarlona - vers√£o simples"""
    await status_lona_detalhado(update, context)

async def relatorio(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /relatorio - vers√£o simples"""
    await relatorio_meteorologico_completo(update, context)

async def alertas_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /alertas - vers√£o simples"""
    await configurar_alertas(update, context)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Comando /help - vers√£o simples"""
    await ajuda_detalhada(update, context)

async def verificar_condicoes_voo(latitude, longitude, nome_local="Local atual"):
    """
    Verifica se as condi√ß√µes s√£o seguras para voo do drone
    """
    previsao = obter_previsao_tempo(latitude, longitude)
    if not previsao:
        return None
    
    current = previsao["current"]
    
    # Analisa condi√ß√µes
    condicoes = {
        'vento': current['wind_kph'],
        'visibilidade': current['vis_km'],
        'temperatura': current['temp_c'],
        'chance_chuva': previsao["forecast"]["forecastday"][0]["hour"][datetime.now().hour].get("chance_of_rain", 0)
    }
    
    # Verifica cada condi√ß√£o
    status = []
    is_safe = True
    
    # Vento
    if condicoes['vento'] > FLIGHT_LIMITS['max_wind']:
        status.append(f"‚ùå Vento muito forte: {condicoes['vento']} km/h")
        is_safe = False
    else:
        status.append(f"‚úÖ Vento adequado: {condicoes['vento']} km/h")
    
    # Visibilidade
    if condicoes['visibilidade'] < FLIGHT_LIMITS['min_visibility']:
        status.append(f"‚ùå Visibilidade baixa: {condicoes['visibilidade']} km")
        is_safe = False
    else:
        status.append(f"‚úÖ Boa visibilidade: {condicoes['visibilidade']} km")
    
    # Temperatura
    if not (FLIGHT_LIMITS['min_temp'] <= condicoes['temperatura'] <= FLIGHT_LIMITS['max_temp']):
        status.append(f"‚ùå Temperatura inadequada: {condicoes['temperatura']}¬∞C")
        is_safe = False
    else:
        status.append(f"‚úÖ Temperatura adequada: {condicoes['temperatura']}¬∞C")
    
    # Chuva
    if condicoes['chance_chuva'] > FLIGHT_LIMITS['max_rain_chance']:
        status.append(f"‚ùå Risco de chuva: {condicoes['chance_chuva']}%")
        is_safe = False
    else:
        status.append(f"‚úÖ Sem risco de chuva: {condicoes['chance_chuva']}%")
    
    return {
        'is_safe': is_safe,
        'status': status,
        'condicoes': condicoes,
        'local': nome_local
    }

async def status_voo_drone(update_obj, context):
    """
    Mostra status detalhado para voo do drone
    """
    previsao = obter_previsao_tempo(LATITUDE, LONGITUDE)
    if not previsao:
        await enviar_resposta(update_obj, "‚ùå N√£o foi poss√≠vel verificar condi√ß√µes de voo.", criar_menu_voltar())
        return
    
    resultado = await verificar_condicoes_voo(LATITUDE, LONGITUDE)
    if not resultado:
        await enviar_resposta(update_obj, "‚ùå Erro ao analisar condi√ß√µes de voo.", criar_menu_voltar())
        return
    
    # Monta mensagem
    mensagem = f"""
üöÅ **STATUS PARA VOO - DJI Mini 2**
üìç Local: {resultado['local']}
{datetime.now().strftime('%d/%m/%Y %H:%M')}

**Status Geral:** {"‚úÖ SEGURO PARA VOO" if resultado['is_safe'] else "‚ùå N√ÉO RECOMENDADO"}

**Condi√ß√µes Atuais:**
"""
    
    for status in resultado['status']:
        mensagem += f"‚Ä¢ {status}\n"
    
    mensagem += f"""
üìã **Especifica√ß√µes do Drone:**
‚Ä¢ Peso: {DRONE_CONFIG['peso']}g
‚Ä¢ Altitude m√°xima: {DRONE_CONFIG['max_altitude']}m
‚Ä¢ Resist√™ncia ao vento: at√© {DRONE_CONFIG['max_wind_resistance']}km/h
‚Ä¢ Autonomia: ~{DRONE_CONFIG['bateria_duracao']} minutos

‚ö†Ô∏è **Recomenda√ß√µes:**"""
    
    if resultado['is_safe']:
        mensagem += """
‚Ä¢ Mantenha contato visual com o drone
‚Ä¢ Respeite os limites de altura e dist√¢ncia
‚Ä¢ Monitore o n√≠vel da bateria
‚Ä¢ Evite √°reas restritas
‚Ä¢ Tenha cuidado com obst√°culos"""
    else:
        mensagem += """
‚Ä¢ N√£o √© recomendado voar nas condi√ß√µes atuais
‚Ä¢ Aguarde condi√ß√µes mais favor√°veis
‚Ä¢ Monitore a previs√£o do tempo"""
    
    await enviar_resposta(update_obj, mensagem, criar_menu_voltar())

async def adicionar_local_drone(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Adiciona um novo local para monitoramento
    """
    try:
        args = context.args
        if len(args) < 3:
            await update.message.reply_text(
                "‚ùå Formato incorreto. Use:\n/addlocal nome latitude longitude\n"
                "Exemplo: /addlocal Parque -5.8802 -35.2477"
            )
            return
        
        nome = args[0]
        lat = float(args[1])
        lon = float(args[2])
        
        alert_state['drone_locations'][nome] = {
            'latitude': lat,
            'longitude': lon
        }
        
        await update.message.reply_text(f"‚úÖ Local '{nome}' adicionado com sucesso!")
        
    except ValueError:
        await update.message.reply_text("‚ùå Coordenadas inv√°lidas!")
    except Exception as e:
        await update.message.reply_text(f"‚ùå Erro ao adicionar local: {str(e)}")

def main():
    """
    Fun√ß√£o principal que inicia o bot
    """
    # Verifica vari√°veis de ambiente
    telegram_token = os.getenv("TELEGRAM_BOT_TOKEN")
    telegram_chat_id = os.getenv("TELEGRAM_CHAT_ID")
    weather_api_key = os.getenv("WEATHERAPI_KEY")
    
    if not telegram_token:
        logger.error("TELEGRAM_BOT_TOKEN n√£o configurado")
        print("‚ùå Configure a vari√°vel de ambiente TELEGRAM_BOT_TOKEN")
        exit(1)
    
    if not weather_api_key:
        logger.error("WEATHERAPI_KEY n√£o configurado")
        print("‚ùå Configure a vari√°vel de ambiente WEATHERAPI_KEY")
        exit(1)
    
    logger.info("Iniciando Bot de Previs√£o do Tempo")
    print(f"ü§ñ Iniciando Bot de Previs√£o do Tempo para {CIDADE_NOME}")
    print(f"üìç Coordenadas: {LATITUDE}, {LONGITUDE}")
    print(f"‚è∞ Intervalo de verifica√ß√£o: {UPDATE_INTERVAL} minutos")
    print(f"üö® Limite de alerta: {ALERT_THRESHOLD}% de chance de chuva")
    
    # Configura a agenda de tarefas
    configurar_agenda()
    
    # Inicia thread para verifica√ß√£o autom√°tica
    thread_verificacao = threading.Thread(
        target=verificacao_automatica,
        daemon=True
    )
    thread_verificacao.start()
    logger.info("Thread de verifica√ß√£o autom√°tica iniciada")
    
    # Inicia thread para agenda
    thread_agenda = threading.Thread(
        target=executar_agenda,
        daemon=True
    )
    thread_agenda.start()
    logger.info("Thread de agenda iniciada")
    
    # Configura o bot do Telegram
    app = ApplicationBuilder().token(telegram_token).build()
    
    # Adiciona handlers para comandos
    comandos = {
        "start": start,
        "help": help_command,
        "clima": clima,
        "chuva": chuva,
        "diasdechuva": diasdechuva,
        "baixarlona": baixarlona,
        "relatorio": relatorio,
        "alertas": alertas_cmd,
        "drone": status_voo_drone,
        "addlocal": adicionar_local_drone
    }
    
    for comando, funcao in comandos.items():
        app.add_handler(CommandHandler(comando, funcao))
    
    # Adiciona handler para bot√µes
    app.add_handler(CallbackQueryHandler(button_handler))
    
    print("‚úÖ Bot configurado e pronto!")
    print("üì± Comandos dispon√≠veis:")
    for comando in comandos:
        print(f"   ‚Ä¢ /{comando}")
    
    # Adiciona o chat_id se fornecido
    if telegram_chat_id:
        alert_state['users_subscribed'].add(telegram_chat_id)
        logger.info(f"Chat ID padr√£o adicionado: {telegram_chat_id}")
    
    print("‚úÖ Bot configurado e pronto!")
    print("üì± Comandos dispon√≠veis:")
    print("   ‚Ä¢ /start - Menu principal")
    print("   ‚Ä¢ /clima - Clima atual")
    print("   ‚Ä¢ /chuva - Previs√£o de chuva")
    print("   ‚Ä¢ /diasdechuva - Pr√≥ximos dias")
    print("   ‚Ä¢ /baixarlona - Status da lona")
    print("   ‚Ä¢ /relatorio - Relat√≥rio completo")
    print("   ‚Ä¢ /alertas - Configurar alertas")
    print("   ‚Ä¢ /help - Ajuda")
    print("\nüîÑ Iniciando bot... (Ctrl+C para parar)")
    
    try:
        # Inicia o bot
        logger.info("Bot iniciado e rodando...")
        app.run_polling()
    except KeyboardInterrupt:
        logger.info("Bot interrompido pelo usu√°rio")
        print("\nüõë Bot interrompido pelo usu√°rio")
    except Exception as e:
        logger.error(f"Erro cr√≠tico no bot: {e}")
        print(f"\n‚ùå Erro cr√≠tico: {e}")
    finally:
        logger.info("Bot finalizado")
        print("üëã Bot finalizado!")

if __name__ == "__main__":
    main()